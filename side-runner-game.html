<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Side Runner+</title>
<style>
  body {
    margin: 0;
    background: #111827;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  #gameCanvas {
    background: linear-gradient(#87ceeb, #68b3e8);
    border: 3px solid #111827;
    border-radius: 8px;
    box-shadow: 0 18px 40px rgba(0,0,0,0.8);
    max-width: 100vw;
    max-height: 100vh;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const W = canvas.width;
  const H = canvas.height;

  // Ground height
  const groundY = H - 60;

  // Player
  const player = {
    x: 80,
    y: groundY - 60,
    width: 40,
    height: 60,
    vy: 0,
    grounded: false,
    lives: 3,
    invincibleTime: 0 // ms
  };

  // Game state
  let gravity = 0.7;
  let jumpStrength = -15;
  let scrollSpeed = 4;
  let score = 0;
  let bestScore = 0;
  let gameOver = false;

  let platforms = [];
  let enemies = [];
  let coins = [];

  let lastSpawnPlatform = 0;
  let lastSpawnEnemy = 0;
  let lastSpawnCoin = 0;

  // Difficulty
  let difficulty = 1; // grows slowly

  // Load best score
  try {
    const stored = localStorage.getItem("sideRunnerBest");
    if (stored) bestScore = Number(stored) || 0;
  } catch (e) {}

  // ---------- SPAWNERS ----------

  function spawnPlatform() {
    const width = 160 + Math.random() * 160;
    const height = 18;
    const y = groundY - (Math.random() * 140 + 60);
    const x = W + width;
    platforms.push({ x, y, width, height });
  }

  function spawnEnemy() {
    // 70% chance on ground, 30% on a random platform (if any)
    if (platforms.length > 0 && Math.random() < 0.3) {
      const p = platforms[Math.floor(Math.random() * platforms.length)];
      enemies.push({
        x: p.x + p.width / 2,
        y: p.y - 35,
        width: 35,
        height: 35
      });
    } else {
      enemies.push({
        x: W + 35,
        y: groundY - 40,
        width: 35,
        height: 40
      });
    }
  }

  function spawnCoin() {
    const baseY = groundY - (Math.random() * 160 + 60);
    coins.push({
      x: W + 25,
      y: baseY,
      r: 11
    });
  }

  // ---------- DRAWING ----------

  function drawBackgroundLayers() {
    // Sky gradient is canvas background

    // Distant hills
    ctx.fillStyle = "#5ca46b";
    const hillBase = groundY + 10;
    ctx.beginPath();
    ctx.moveTo(0, hillBase);
    for (let x = 0; x <= W; x += 80) {
      ctx.quadraticCurveTo(
        x + 40,
        hillBase - 40 - 20 * Math.sin((x + hillOffset * 0.5) * 0.01),
        x + 80,
        hillBase
      );
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();

    // Clouds
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    drawCloud(80 + cloudOffset * 0.5, 80);
    drawCloud(280 + cloudOffset * 0.4, 60);
    drawCloud(520 + cloudOffset * 0.6, 90);
  }

  function drawCloud(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.arc(x + 18, y + 6, 18, 0, Math.PI * 2);
    ctx.arc(x - 18, y + 6, 18, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawGround() {
    // Ground strip
    ctx.fillStyle = "#3b7c3f";
    ctx.fillRect(0, groundY, W, H - groundY);

    // Ground detail
    ctx.fillStyle = "#2f5f31";
    for (let x = (groundOffset % 40) - 40; x < W; x += 40) {
      ctx.fillRect(x, groundY + 22, 30, 8);
    }
  }

  function drawPlayer() {
    // body
    ctx.fillStyle = "#ff4b4b";
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // face
    ctx.fillStyle = "#ffd7a6";
    ctx.fillRect(player.x + 6, player.y + 8, player.width - 12, 20);

    // eyes
    ctx.fillStyle = "#333";
    ctx.fillRect(player.x + 12, player.y + 14, 4, 4);
    ctx.fillRect(player.x + player.width - 16, player.y + 14, 4, 4);

    // if invincible, outline
    if (player.invincibleTime > 0) {
      ctx.strokeStyle = "rgba(248,250,252,0.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(player.x - 2, player.y - 2, player.width + 4, player.height + 4);
    }
  }

  function drawPlatform(p) {
    ctx.fillStyle = "#7b4a2e";
    ctx.fillRect(p.x, p.y, p.width, p.height);
    ctx.fillStyle = "#9f6a3a";
    ctx.fillRect(p.x, p.y, p.width, 5);
  }

  function drawEnemy(e) {
    ctx.fillStyle = "#228B22";
    ctx.fillRect(e.x, e.y, e.width, e.height);
    // simple eyes
    ctx.fillStyle = "#fff";
    ctx.fillRect(e.x + 7, e.y + 8, 6, 6);
    ctx.fillRect(e.x + e.width - 13, e.y + 8, 6, 6);
    ctx.fillStyle = "#000";
    ctx.fillRect(e.x + 9, e.y + 10, 3, 3);
    ctx.fillRect(e.x + e.width - 11, e.y + 10, 3, 3);
  }

  function drawCoin(c) {
    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#b8860b";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawUI() {
    ctx.fillStyle = "#00000090";
    ctx.fillRect(0, 0, W, 40);

    ctx.fillStyle = "#f9fafb";
    ctx.font = "16px system-ui";
    ctx.textAlign = "left";
    ctx.fillText("Score: " + Math.floor(score), 16, 25);

    ctx.textAlign = "center";
    ctx.fillText("Best: " + Math.floor(bestScore), W / 2, 25);

    // Lives (hearts)
    ctx.textAlign = "right";
    let hearts = "";
    for (let i = 0; i < player.lives; i++) hearts += "â¤ ";
    ctx.fillText("Lives: " + hearts.trim(), W - 16, 25);
  }

  function drawGameOver() {
    if (!gameOver) return;

    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#f9fafb";
    ctx.textAlign = "center";
    ctx.font = "bold 40px system-ui";
    ctx.fillText("GAME OVER", W / 2, H / 2 - 20);

    ctx.font = "18px system-ui";
    ctx.fillText("Score: " + Math.floor(score) + "  |  Best: " + Math.floor(bestScore), W / 2, H / 2 + 10);
    ctx.font = "16px system-ui";
    ctx.fillText("Click or press SPACE to restart", W / 2, H / 2 + 40);
  }

  // ---------- BACKGROUND MOTION ----------

  let cloudOffset = 0;
  let hillOffset = 0;
  let groundOffset = 0;

  // ---------- GAME LOOP ----------

  function jump() {
    if (gameOver) return;
    if (player.grounded) {
      player.vy = jumpStrength;
      player.grounded = false;
    }
  }

  function restart() {
    score = 0;
    difficulty = 1;
    scrollSpeed = 4;
    player.x = 80;
    player.y = groundY - 60;
    player.vy = 0;
    player.grounded = false;
    player.lives = 3;
    player.invincibleTime = 0;
    platforms = [];
    enemies = [];
    coins = [];
    gameOver = false;
  }

  function update(dt) {
    if (gameOver) return;

    // Difficulty ramp (slow)
    difficulty = 1 + score / 800;
    if (difficulty > 2.2) difficulty = 2.2;
    scrollSpeed = 4 * difficulty;

    // Player physics
    player.vy += gravity;
    player.y += player.vy;

    // Ground collision
    if (player.y + player.height > groundY) {
      player.y = groundY - player.height;
      player.vy = 0;
      player.grounded = true;
    }

    // Platforms
    player.grounded = (player.y + player.height >= groundY - 0.5); // re-check

    platforms.forEach(p => {
      // scroll
      p.x -= scrollSpeed;

      // landing check, only if moving down
      if (player.vy >= 0 &&
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height <= p.y + 10 &&
          player.y + player.height >= p.y - 20) {
        player.y = p.y - player.height;
        player.vy = 0;
        player.grounded = true;
      }
    });

    // Background motion
    cloudOffset -= scrollSpeed * 0.3;
    hillOffset -= scrollSpeed * 0.4;
    groundOffset -= scrollSpeed;

    // Enemies & coins move
    enemies.forEach(e => e.x -= scrollSpeed);
    coins.forEach(c => c.x -= scrollSpeed);

    // Spawning (based on frames, scaled by difficulty)
    lastSpawnPlatform += dt;
    lastSpawnEnemy += dt;
    lastSpawnCoin += dt;

    const platformFreq = 1200;
    const enemyFreq = 1100 / difficulty;
    const coinFreq = 800;

    if (lastSpawnPlatform > platformFreq) {
      spawnPlatform();
      lastSpawnPlatform = 0;
    }

    if (lastSpawnEnemy > enemyFreq) {
      spawnEnemy();
      lastSpawnEnemy = 0;
    }

    if (lastSpawnCoin > coinFreq) {
      spawnCoin();
      lastSpawnCoin = 0;
    }

    // Clean up off-screen
    platforms = platforms.filter(p => p.x + p.width > -80);
    enemies = enemies.filter(e => e.x + e.width > -80);
    coins = coins.filter(c => c.x + c.r > -80);

    // Coin pickups
    coins.forEach((c, index) => {
      const px = player.x + player.width / 2;
      const py = player.y + player.height / 2;
      const dist = Math.hypot(px - c.x, py - c.y);
      if (dist < c.r + 18) {
        score += 10;
        coins.splice(index, 1);
      }
    });

    // Enemy collision
    if (player.invincibleTime > 0) {
      player.invincibleTime -= dt;
      if (player.invincibleTime < 0) player.invincibleTime = 0;
    }

    enemies.forEach(e => {
      if (
        player.x < e.x + e.width &&
        player.x + player.width > e.x &&
        player.y < e.y + e.height &&
        player.y + player.height > e.y
      ) {
        if (player.invincibleTime <= 0) {
          player.lives--;
          player.invincibleTime = 1200; // 1.2s invincibility
          if (player.lives <= 0) {
            gameOver = true;
            // update best
            if (score > bestScore) {
              bestScore = score;
              try {
                localStorage.setItem("sideRunnerBest", String(bestScore));
              } catch (e) {}
            }
          }
        }
      }
    });

    // Increase score over time
    score += dt * 0.01 * difficulty;
  }

  function render() {
    ctx.clearRect(0, 0, W, H);

    drawBackgroundLayers();
    drawGround();

    platforms.forEach(drawPlatform);
    enemies.forEach(drawEnemy);
    coins.forEach(drawCoin);
    drawPlayer();
    drawUI();
    drawGameOver();
  }

  let lastTime = 0;
  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // ---------- INPUT: CLICK/TAP JUMP & SPACE ----------

  canvas.addEventListener("click", () => {
    if (gameOver) {
      restart();
    } else {
      jump(); // CLICK TO JUMP
    }
  });

  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    if (gameOver) {
      restart();
    } else {
      jump(); // TAP TO JUMP (MOBILE)
    }
  }, { passive: false });

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      if (gameOver) restart();
      else jump();
    }
  });
})();
</script>
</body>
</html>
