<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Car Crash Runner+</title>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617, #000000);
      color: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .game-wrapper {
      margin: 1.5rem auto;
      padding: 1rem 1.25rem 1.5rem;
      border-radius: 14px;
      background: rgba(10, 12, 22, 0.96);
      box-shadow: 0 18px 40px rgba(0,0,0,0.9);
      max-width: 480px;
      width: 100%;
      box-sizing: border-box;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.35rem;
    }

    .game-header h2 {
      margin: 0;
      font-size: 1.2rem;
    }

    .game-subtitle {
      font-size: 0.85rem;
      opacity: 0.85;
      margin-bottom: 0.6rem;
      line-height: 1.3;
    }

    .game-stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      row-gap: 0.2rem;
      column-gap: 0.5rem;
      font-size: 0.82rem;
      margin-bottom: 0.4rem;
      opacity: 0.9;
    }

    .game-stats span strong {
      font-weight: 600;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      max-width: 480px;
      border-radius: 12px;
      background: #020617;
      margin: 0.3rem auto;
    }

    .game-footer {
      margin-top: 0.6rem;
      font-size: 0.75rem;
      opacity: 0.9;
      text-align: center;
      line-height: 1.4;
    }

    .game-footer span {
      display: block;
      margin: 0.05rem 0;
    }

    #muteBtn {
      margin-top: 0.35rem;
      border-radius: 999px;
      border: none;
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      cursor: pointer;
      background: #111827;
      color: #e5e7eb;
    }
  </style>
</head>
<body>

  <div class="game-wrapper">
    <div class="game-header">
      <h2>üöó Car Crash Runner+</h2>
      <div>Score: <span id="scoreDisplay">0</span></div>
    </div>
    <div class="game-subtitle">
      Steer with your mouse (or finger). Dodge traffic, grab coins, and use power-ups.
      Crash ends the run‚Ä¶ unless your shield saves you.
    </div>

    <div class="game-stats">
      <span>Best: <strong id="bestScoreDisplay">0</strong></span>
      <span>Speed: <strong id="speedDisplay">1.0x</strong></span>
      <span>Shield: <strong id="shieldStatus">‚Äì</strong></span>
      <span>Slow-mo: <strong id="slowStatus">‚Äì</strong></span>
    </div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <div class="game-footer">
      <span>Move mouse (or drag your finger) left/right over the road to steer.</span>
      <span>Collect ü™ô coins for bonus score, üõ°Ô∏è for shield, üê¢ for slow-mo.</span>
      <span>Click or press <strong>Space</strong> after a crash to restart.</span>
      <button id="muteBtn">üîä Sound: On</button>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const scoreEl = document.getElementById("scoreDisplay");
      const bestEl = document.getElementById("bestScoreDisplay");
      const speedEl = document.getElementById("speedDisplay");
      const shieldEl = document.getElementById("shieldStatus");
      const slowEl = document.getElementById("slowStatus");
      const muteBtn = document.getElementById("muteBtn");

      const W = canvas.width;
      const H = canvas.height;

      // Road configuration
      const road = {
        left: 80,
        right: 320,
        laneCount: 3
      };

      // Player car
      const car = {
        width: 40,
        height: 80,
        x: W / 2,
        y: H - 110,
        color: "#4ade80"
      };

      let obstacles = [];
      let collectibles = []; // coins & powerups
      let lastSpawnCar = 0;
      let lastSpawnCollectible = 0;
      let spawnCarInterval = 1100;
      let spawnCollectibleInterval = 1400;
      let roadOffset = 0;

      let running = true;
      let lastTime = 0;
      let score = 0;
      let best = 0;
      const BEST_KEY = "carCrashRunnerPlusBest";

      // Difficulty
      let baseSpeed = 200;
      let difficultyMultiplier = 1;

      // Power-ups
      let shieldActive = false;
      let slowTimeLeft = 0;
      const SLOW_DURATION = 4000;

      // Audio
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null;
      let muted = false;

      function initAudio() {
        if (!audioCtx && AudioContext) {
          try {
            audioCtx = new AudioContext();
          } catch (e) {
            audioCtx = null;
          }
        }
      }

      function playBeep(type) {
        if (muted || !AudioContext) return;
        initAudio();
        if (!audioCtx) return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        let freq = 440;
        let duration = 0.12;

        switch (type) {
          case "lane":  freq = 720; duration = 0.06; break;
          case "coin":  freq = 840; duration = 0.09; break;
          case "power": freq = 550; duration = 0.12; break;
          case "crash": freq = 180; duration = 0.25; break;
          default:      freq = 500; duration = 0.08; break;
        }

        osc.frequency.value = freq;
        gain.gain.value = 0.18;
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        osc.start(now);
        osc.stop(now + duration);
      }

      muteBtn.addEventListener("click", () => {
        muted = !muted;
        muteBtn.textContent = muted ? "üîà Sound: Off" : "üîä Sound: On";
      });

      // Load best score
      try {
        const stored = localStorage.getItem(BEST_KEY);
        if (stored) {
          best = Number(stored) || 0;
          bestEl.textContent = best;
        }
      } catch (e) {}

      function resetGame() {
        obstacles = [];
        collectibles = [];
        score = 0;
        baseSpeed = 200;
        difficultyMultiplier = 1;
        spawnCarInterval = 1100;
        spawnCollectibleInterval = 1400;
        car.x = W / 2;
        running = true;
        lastSpawnCar = 0;
        lastSpawnCollectible = 0;
        roadOffset = 0;
        shieldActive = false;
        slowTimeLeft = 0;

        scoreEl.textContent = "0";
        speedEl.textContent = "1.0x";
        shieldEl.textContent = "‚Äì";
        slowEl.textContent = "‚Äì";
      }

      function spawnObstacle() {
        const laneWidth = (road.right - road.left) / road.laneCount;
        const laneIndex = Math.floor(Math.random() * road.laneCount);
        const carWidth = 40;
        const carHeight = 80;
        const x = road.left + laneWidth * laneIndex + laneWidth / 2;

        obstacles.push({
          x,
          y: -carHeight,
          width: carWidth,
          height: carHeight,
          color: "#f97373"
        });
      }

      function spawnCollectible() {
        const laneWidth = (road.right - road.left) / road.laneCount;
        const laneIndex = Math.floor(Math.random() * road.laneCount);
        const x = road.left + laneWidth * laneIndex + laneWidth / 2;

        const types = ["coin", "shield", "slow"];
        const r = Math.random();
        let type;
        if (r < 0.6) type = "coin";
        else if (r < 0.8) type = "shield";
        else type = "slow";

        collectibles.push({
          x,
          y: -20,
          radius: 14,
          type,
          vy: 180
        });
      }

      function rectsOverlap(a, b) {
        return !(
          a.x - a.width / 2 > b.x + b.width / 2 ||
          a.x + a.width / 2 < b.x - b.width / 2 ||
          a.y - a.height / 2 > b.y + b.height / 2 ||
          a.y + a.height / 2 < b.y - b.height / 2
        );
      }

      function drawRoad(dt) {
        // background
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, W, H);

        // subtle side glow
        const g = ctx.createLinearGradient(0, 0, W, 0);
        g.addColorStop(0, "rgba(59,130,246,0.15)");
        g.addColorStop(0.5, "rgba(0,0,0,0)");
        g.addColorStop(1, "rgba(244,114,182,0.15)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        // road scroll
        const speed = baseSpeed * (slowTimeLeft > 0 ? 0.3 : 1) * difficultyMultiplier;
        roadOffset += speed * dt * 0.001;
        if (roadOffset > 40) roadOffset -= 40;

        // road base
        ctx.fillStyle = "#1f2933";
        ctx.fillRect(road.left, 0, road.right - road.left, H);

        // road edges
        ctx.fillStyle = "#0b0f19";
        ctx.fillRect(road.left - 8, 0, 8, H);
        ctx.fillRect(road.right, 0, 8, H);

        // lane dividers
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 3;
        ctx.setLineDash([18, 18]);
        ctx.lineDashOffset = roadOffset;

        const laneWidth = (road.right - road.left) / road.laneCount;
        for (let i = 1; i < road.laneCount; i++) {
          const x = road.left + laneWidth * i;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }

        ctx.setLineDash([]);
      }

      function drawCar(obj, isPlayer = false) {
        ctx.save();
        ctx.translate(obj.x, obj.y);

        ctx.fillStyle = obj.color;
        ctx.fillRect(-obj.width / 2, -obj.height / 2, obj.width, obj.height);

        // windows
        ctx.fillStyle = isPlayer ? "#bbf7d0" : "#fecaca";
        ctx.fillRect(-obj.width / 2 + 6, -obj.height / 2 + 10, obj.width - 12, 20);

        // highlight
        if (isPlayer && shieldActive) {
          ctx.strokeStyle = "rgba(96,165,250,0.9)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.roundRect(-obj.width / 2 - 4, -obj.height / 2 - 4, obj.width + 8, obj.height + 8, 8);
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawCollectible(c) {
        ctx.save();
        ctx.translate(c.x, c.y);

        if (c.type === "coin") {
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(0, 0, c.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#854d0e";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("ü™ô", 0, 1);
        } else if (c.type === "shield") {
          ctx.fillStyle = "rgba(59,130,246,0.9)";
          ctx.beginPath();
          ctx.arc(0, 0, c.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("üõ°Ô∏è", 0, 1);
        } else if (c.type === "slow") {
          ctx.fillStyle = "rgba(56,189,248,0.9)";
          ctx.beginPath();
          ctx.arc(0, 0, c.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("üê¢", 0, 1);
        }

        ctx.restore();
      }

      function drawCrashOverlay() {
        if (running) return;

        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = "#f9fafb";
        ctx.textAlign = "center";

        ctx.font = "bold 32px system-ui";
        ctx.fillText("CRASHED!", W / 2, H / 2 - 22);

        ctx.font = "16px system-ui";
        ctx.fillText("Score: " + Math.floor(score), W / 2, H / 2 + 8);
        ctx.fillText("Best: " + best, W / 2, H / 2 + 30);

        ctx.font = "14px system-ui";
        ctx.fillText("Click or press Space to restart", W / 2, H / 2 + 55);

        ctx.restore();
      }

      function handleCrash() {
        if (shieldActive) {
          // Shield absorbs crash
          shieldActive = false;
          shieldEl.textContent = "‚Äì";
          playBeep("power");
          // Clear nearest obstacle
          if (obstacles.length > 0) {
            obstacles.shift();
          }
          return;
        }

        running = false;
        playBeep("crash");

        const finalScore = Math.floor(score);
        if (finalScore > best) {
          best = finalScore;
          bestEl.textContent = best;
          try {
            localStorage.setItem(BEST_KEY, String(best));
          } catch (e) {}
        }
      }

      function update(dt) {
        if (!running) return;

        // Slow-mo timer
        if (slowTimeLeft > 0) {
          slowTimeLeft -= dt;
          if (slowTimeLeft < 0) slowTimeLeft = 0;
        }
        slowEl.textContent = slowTimeLeft > 0 ? (slowTimeLeft/1000).toFixed(1) + "s" : "‚Äì";
        shieldEl.textContent = shieldActive ? "Ready" : "‚Äì";

        // Difficulty scaling by score
        const diffBase = 1 + score / 250;
        difficultyMultiplier = diffBase;
        speedEl.textContent = diffBase.toFixed(1) + "x";

        const effectiveSpeedFactor = diffBase * (slowTimeLeft > 0 ? 0.35 : 1);

        baseSpeed = 200 * effectiveSpeedFactor;
        spawnCarInterval = 1100 / diffBase;
        spawnCollectibleInterval = 1400 / diffBase;

        // Increase score over time
        score += dt * 0.012 * diffBase;
        scoreEl.textContent = Math.floor(score);

        // Move road & call drawRoad in main loop

        // Move obstacles
        const obstacleSpeed = baseSpeed * 0.9;
        for (const o of obstacles) {
          o.y += obstacleSpeed * dt * 0.001;
        }

        // Move collectibles
        for (const c of collectibles) {
          c.y += c.vy * dt * 0.001;
        }

        // Remove off-screen
        obstacles = obstacles.filter(o => o.y < H + 120);
        collectibles = collectibles.filter(c => c.y < H + 40);

        // Spawn new traffic
        lastSpawnCar += dt;
        if (lastSpawnCar >= spawnCarInterval) {
          spawnObstacle();
          lastSpawnCar = 0;
        }

        // Spawn collectibles
        lastSpawnCollectible += dt;
        if (lastSpawnCollectible >= spawnCollectibleInterval) {
          spawnCollectible();
          lastSpawnCollectible = 0;
        }

        // Collision with obstacles
        for (const o of obstacles) {
          if (rectsOverlap(car, o)) {
            handleCrash();
            break;
          }
        }

        // Collision with collectibles
        for (let i = collectibles.length - 1; i >= 0; i--) {
          const c = collectibles[i];
          const dx = car.x - c.x;
          const dy = car.y - c.y;
          const dist = Math.hypot(dx, dy);
          if (dist < c.radius + Math.min(car.width, car.height)/3) {
            // pickup
            if (c.type === "coin") {
              score += 10;
              playBeep("coin");
            } else if (c.type === "shield") {
              shieldActive = true;
              playBeep("power");
            } else if (c.type === "slow") {
              slowTimeLeft = SLOW_DURATION;
              playBeep("power");
            }
            collectibles.splice(i, 1);
          }
        }

        // If car somehow leaves road, clamp it
        const minX = road.left + car.width / 2;
        const maxX = road.right - car.width / 2;
        if (car.x < minX) car.x = minX;
        if (car.x > maxX) car.x = maxX;
      }

      function draw() {
        // background + road
        drawRoad(16); // dt-ish for visual; actual scroll uses update

        // draw collectibles
        for (const c of collectibles) {
          drawCollectible(c);
        }

        // draw obstacles
        for (const o of obstacles) {
          drawCar(o, false);
        }

        // draw player
        drawCar(car, true);

        // overlay if crashed
        drawCrashOverlay();
      }

      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;

        update(dt);
        draw();

        requestAnimationFrame(gameLoop);
      }

      // INPUT HANDLING

      function handlePointerMove(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const newX = Math.max(road.left + car.width / 2, Math.min(road.right - car.width / 2, x));
        const movedLane = Math.abs(newX - car.x) > 6;
        car.x = newX;
        if (movedLane && running) {
          playBeep("lane");
        }
      }

      canvas.addEventListener("mousemove", (e) => {
        handlePointerMove(e.clientX);
      });

      canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length > 0) {
          handlePointerMove(e.touches[0].clientX);
        }
      }, { passive: true });

      canvas.addEventListener("touchmove", (e) => {
        if (e.touches.length > 0) {
          handlePointerMove(e.touches[0].clientX);
        }
      }, { passive: true });

      canvas.addEventListener("click", () => {
        if (!running) {
          resetGame();
        }
      });

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (!running) {
            resetGame();
          }
        }
      });

      // Start
      resetGame();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
